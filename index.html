<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f17" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <link rel="manifest" href="./manifest.webmanifest" />
  <link rel="icon" href="./icon-192.png" sizes="192x192" />
  <link rel="apple-touch-icon" href="./apple-touch-icon.png" />

  <title>P2P Chat (WebRTC) ‚Äî –≥—Ä—É–ø–ø—ã + E2EE + QR + signaling</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:#0b0f17;
      color:#e7eefc;
    }
    .wrap {
      max-width: 1160px;
      margin: 0 auto;
      padding:
        calc(16px + env(safe-area-inset-top))
        calc(16px + env(safe-area-inset-right))
        calc(16px + env(safe-area-inset-bottom))
        calc(16px + env(safe-area-inset-left));
      display: grid;
      gap: 14px;
    }
    h1 { font-size: 18px; margin: 8px 0 0; }
    .grid { display:grid; grid-template-columns: 1.1fr .9fr; gap: 12px; }
    @media (max-width: 980px){ .grid { grid-template-columns: 1fr; } }

    .card { background:#121a28; border:1px solid #1f2a3e; border-radius: 14px; padding: 12px; box-shadow: 0 12px 40px rgba(0,0,0,.25); }
    label { display:block; font-size: 12px; opacity:.85; margin: 6px 0; }

    textarea, input, select {
      width:100%; box-sizing:border-box;
      border-radius: 12px; border:1px solid #24334d;
      background:#0c1422; color:#e7eefc;
      padding: 10px;
      outline:none;
    }
    textarea {
      min-height: 124px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
    }

    /* iOS Safari: prevent zoom on focus */
    @media (max-width: 980px){
      input, textarea, select { font-size: 16px; }
      textarea { font-size: 14px; }
    }

    .row { display:flex; gap:10px; flex-wrap: wrap; align-items: center; }

    button {
      border: 0; border-radius: 12px;
      padding: 10px 12px;
      background:#2b67ff;
      color:white;
      cursor:pointer;
      font-weight:700;
    }
    button.secondary { background:#22304a; font-weight:650; }
    button.danger { background:#ff3b5c; font-weight:700; }
    button:disabled { opacity: .55; cursor:not-allowed; }

    .statusLine { display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content: space-between; }
    .pill { font-size: 12px; opacity: .95; padding: 6px 10px; border-radius: 999px; border:1px solid #24334d; background:#0c1422; }
    .pill.ok { border-color:#2a4a8f; background:#0d1c38; }
    .pill.bad { border-color:#7a2031; background:#230a10; }

    .help { font-size: 12px; opacity: .86; line-height: 1.35; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .hr { height:1px; background:#1f2a3e; margin: 10px 0; }
    .smallbtn { padding: 8px 10px; border-radius: 10px; font-weight:650; }

    .chat { height: 340px; overflow:auto; background:#0c1422; border:1px solid #24334d; border-radius: 14px; padding: 10px; }
    .msg { margin: 8px 0; display:flex; }
    .bubble {
      max-width: 88%;
      padding: 8px 10px;
      border-radius: 14px;
      border:1px solid #24334d;
      background:#0f1b30;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .me { justify-content: flex-end; }
    .me .bubble { background:#173060; border-color:#2a4a8f; }
    .sys { justify-content: center; }
    .sys .bubble { background:#101827; opacity:.92; font-size:12px; }

    .kv { display:grid; grid-template-columns: 170px 1fr; gap: 6px 10px; font-size: 12px; opacity:.9; }

    /* Participants */
    .plist {
      max-height: 220px;
      overflow: auto;
      border:1px solid #24334d;
      border-radius: 14px;
      background:#0c1422;
      padding: 8px;
    }
    .prow { display:flex; gap:10px; align-items:flex-start; padding: 8px 6px; border-bottom:1px solid rgba(36,51,77,.6); }
    .prow:last-child { border-bottom:0; }
    .dot { width:10px; height:10px; border-radius:999px; margin-top: 4px; flex: 0 0 10px; background:#6b7280; }
    .dot.ok { background:#22c55e; }
    .dot.warn { background:#f59e0b; }
    .dot.bad { background:#ef4444; }
    .pname { font-weight: 700; font-size: 13px; line-height: 1.2; }
    .pmeta { font-size: 12px; opacity: .82; line-height: 1.25; }
    .pmeta .mono { font-size: 11px; }
    .pactions { display:flex; gap:8px; align-items:center; }
    .tag { font-size: 11px; padding: 2px 8px; border-radius: 999px; border:1px solid #24334d; background:#0f1b30; opacity:.9; }
    .tag.bad { border-color:#7a2031; background:#230a10; }
    .tag.ok { border-color:#2a4a8f; background:#0d1c38; }

    canvas.qr { width: 220px; height: 220px; border-radius: 14px; border:1px solid #24334d; background:white; }
    .two { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 980px){ .two { grid-template-columns: 1fr; } }

    .muted { opacity:.78; }
    .warn { color: #ffd28a; }
    .good { color: #a6ffcc; }
    .bad { color: #ff9aa9; }

    video { width: 100%; border-radius: 14px; border:1px solid #24334d; background:#0c1422; }

    .inlineIcon { display:inline-block; transform: translateY(1px); }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üîó P2P Chat (WebRTC DataChannel) ‚Äî –≥—Ä—É–ø–ø—ã + üîíE2EE + QR + Cloudflare —Å–∏–≥–Ω–∞–ª–∏–Ω–≥</h1>
    <div class="help">
      <b>–û—Å–Ω–æ–≤–Ω–æ–π —Å—Ü–µ–Ω–∞—Ä–∏–π –¥–ª—è GitHub Pages (Android/iPhone):</b> –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ <b>—Ä–µ–∂–∏–º –∫–æ–º–Ω–∞—Ç—ã</b> (Cloudflare —Å–∏–≥–Ω–∞–ª–∏–Ω–≥). –û–Ω –Ω—É–∂–µ–Ω —Ç–æ–ª—å–∫–æ –¥–ª—è –æ–±–º–µ–Ω–∞ —Å–∏–≥–Ω–∞–ª–∞–º–∏ WebRTC.
      –°–æ–æ–±—â–µ–Ω–∏—è —á–∞—Ç–∞ –∏–¥—É—Ç <b>–Ω–∞–ø—Ä—è–º—É—é P2P</b>.
      <br/><span class="warn">–í–∞–∂–Ω–æ:</span> –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Å–µ—Ç—è—Ö WebRTC –º–æ–∂–µ—Ç –Ω–µ –ø—Ä–æ–±–∏—Ç—å NAT –±–µ–∑ TURN ‚Äî —Ç–æ–≥–¥–∞ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –±–ª–æ–∫ STUN/TURN.
    </div>

    <div class="grid">
      <div class="card">
        <div class="statusLine">
          <div class="row">
            <span class="pill" id="pillPeers">Peers: 0</span>
            <span class="pill" id="pillDC">DC: 0</span>
            <span class="pill" id="pillICE">ICE: idle</span>
            <span class="pill" id="pillWS">WS: off</span>
            <span class="pill" id="pillE2EE">E2EE: off</span>
          </div>
          <div class="row">
            <button id="btnReset" class="danger smallbtn" title="–ó–∞–∫—Ä—ã—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∏ –æ—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª—è">–°–±—Ä–æ—Å</button>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row">
          <div style="flex:1 1 260px;">
            <label>–í–∞—à–µ –∏–º—è (–≤–∏–¥—è—Ç –¥—Ä—É–≥–∏–µ, —Ö—Ä–∞–Ω–∏—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ)</label>
            <input id="name" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: Maxim" />
          </div>
          <div style="flex:1 1 260px;">
            <label>–ü–∞—Ä–æ–ª—å –∫–æ–º–Ω–∞—Ç—ã (E2EE) ‚Äî –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä</label>
            <div class="row" style="gap:8px;">
              <input id="e2eePass" type="password" placeholder="(–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)" autocomplete="off" style="flex:1 1 auto;" />
              <button id="btnTogglePass" class="secondary smallbtn" type="button" title="–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –ø–∞—Ä–æ–ª—å">üëÅÔ∏è</button>
            </div>
            <div class="help muted">–ï—Å–ª–∏ –ø–∞—Ä–æ–ª—å —Ä–∞–∑–Ω—ã–π ‚Äî —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–µ —Ä–∞—Å—à–∏—Ñ—Ä—É—é—Ç—Å—è (—É–≤–∏–¥–∏—Ç–µ –æ—à–∏–±–∫—É). –ú–µ–Ω—è—Ç—å –ø–∞—Ä–æ–ª—å –≤–æ –≤—Ä–µ–º—è —á–∞—Ç–∞ –Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è.</div>
          </div>
        </div>

        <details style="margin-top:10px;" open>
          <summary class="help"><b>–†–µ–∂–∏–º B (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è): –∫–æ–º–Ω–∞—Ç–∞ (Cloudflare —Å–∏–≥–Ω–∞–ª–∏–Ω–≥) ‚Äî –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç</b></summary>
          <div class="hr"></div>

          <div class="row">
            <div style="flex:1 1 360px;">
              <label>URL WebSocket —Å–∏–≥–Ω–∞–ª–∏–Ω–≥–∞ (–ø—Ä–∏–º–µ—Ä: <span class="mono">wss://YOUR-WORKER.workers.dev/ws</span>)</label>
              <input id="wsUrl" placeholder="wss://YOUR-WORKER.workers.dev/ws" />
            </div>
            <div style="flex:1 1 180px;">
              <label>–ö–æ–º–Ω–∞—Ç–∞</label>
              <input id="room" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: 7Q2K9B" />
            </div>
          </div>

          <div class="row" style="margin-top:10px;">
            <button id="btnRoomNew">–°–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É</button>
            <button id="btnWsConnect" class="secondary">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
            <button id="btnWsDisconnect" class="secondary" disabled>–û—Ç–∫–ª—é—á–∏—Ç—å—Å—è</button>
          </div>

          <div class="row" style="margin-top:10px;">
            <div style="flex:1 1 520px;">
              <label>–°—Å—ã–ª–∫–∞‚Äë–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ (–µ—ë –º–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∏–ª–∏ –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –≤ QR)</label>
              <input id="inviteLink" readonly class="mono" placeholder="(—Å–æ–∑–¥–∞–π—Ç–µ –∫–æ–º–Ω–∞—Ç—É –∏–ª–∏ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–ª—è –≤—ã—à–µ)" />
            </div>
            <div class="row" style="align-items:flex-end;">
              <button id="btnCopyInvite" class="secondary smallbtn">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
              <button id="btnShareInvite" class="secondary smallbtn">–ü–æ–¥–µ–ª–∏—Ç—å—Å—è</button>
              <button id="btnMakeRoomQr" class="secondary smallbtn">QR</button>
            </div>
          </div>

          <div class="row" style="margin-top:10px; align-items:flex-start;">
            <canvas class="qr" id="qrRoom" width="220" height="220" aria-label="QR –∫–æ–º–Ω–∞—Ç—ã"></canvas>
            <div class="help muted" style="flex: 1 1 360px;">
              <div><b>–ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç:</b></div>
              <ol>
                <li>–ü–æ–¥–∫–ª—é—á–∞–µ—Ç–µ—Å—å –∫ –∫–æ–º–Ω–∞—Ç–µ –ø–æ WS.</li>
                <li>–ù–æ–≤—ã–π —É—á–∞—Å—Ç–Ω–∏–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞—ë—Ç P2P‚Äë—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ (WebRTC) —Å –∫–∞–∂–¥—ã–º —É–∂–µ –ø–æ–¥–∫–ª—é—á—ë–Ω–Ω—ã–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–º (mesh).</li>
                <li>–°–µ—Ä–≤–µ—Ä –ø–µ—Ä–µ—Å—ã–ª–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Å–∏–≥–Ω–∞–ª–∏–Ω–≥. –°–æ–æ–±—â–µ–Ω–∏—è —á–∞—Ç–∞ –Ω–µ —Ö—Ä–∞–Ω—è—Ç—Å—è.</li>
              </ol>
              <div class="warn">–°–∫–∞–ª–∏—Ä–æ–≤–∞–Ω–∏–µ mesh: –Ω–∞–≥—Ä—É–∑–∫–∞ —Ä–∞—Å—Ç—ë—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ –∫–∞–∫ n¬≤ (–ø–æ —á–∏—Å–ª—É —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π).</div>
            </div>
          </div>

          <div class="two" style="margin-top:10px;">
            <div>
              <label style="margin:0;">–°–∫–∞–Ω–µ—Ä QR (–≤—Å—Ç–∞–≤–∏—Ç —Å—Å—ã–ª–∫—É/SDP)</label>
              <div class="row" style="margin-top:6px;">
                <button id="btnScanStart" class="secondary smallbtn">–°—Ç–∞—Ä—Ç</button>
                <button id="btnScanStop" class="secondary smallbtn" disabled>–°—Ç–æ–ø</button>
              </div>
              <video id="scanVideo" playsinline muted></video>
              <div class="help muted" style="margin-top:6px;">
                –ö–∞–º–µ—Ä–∞ —Ç—Ä–µ–±—É–µ—Ç HTTPS –∏–ª–∏ <span class="mono">localhost</span>. –ù–∞ iPhone –º–æ–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å QR —Å–∏—Å—Ç–µ–º–Ω–æ–π –∫–∞–º–µ—Ä–æ–π (QR ‚Äî —ç—Ç–æ —Å—Å—ã–ª–∫–∞).
              </div>
            </div>
            <div>
              <label>–ü–æ–¥—Å–∫–∞–∑–∫–∞ –ø–æ E2EE</label>
              <div class="help muted">
                üîí –ü–∞—Ä–æ–ª—å –∫–æ–º–Ω–∞—Ç—ã <b>–Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è</b> –∏ <b>–Ω–µ —Ö—Ä–∞–Ω–∏—Ç—Å—è</b> –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ —Å–∏–≥–Ω–∞–ª–∏–Ω–≥–∞.
                –ü–µ—Ä–µ–¥–∞–π—Ç–µ –ø–∞—Ä–æ–ª—å –≤—Ç–æ—Ä–æ–º—É —á–µ–ª–æ–≤–µ–∫—É –æ—Ç–¥–µ–ª—å–Ω—ã–º –∫–∞–Ω–∞–ª–æ–º.
                <br/>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –¥–æ–≥–æ–≤–æ—Ä–∏—Ç—å—Å—è –æ –ø–∞—Ä–æ–ª–µ –∑–∞—Ä–∞–Ω–µ–µ.
              </div>
            </div>
          </div>
        </details>

        <details style="margin-top:10px;">
          <summary class="help"><b>–†–µ–∂–∏–º A (1-–Ω–∞-1): –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞ ‚Äî copy/paste –∏–ª–∏ QR Offer/Answer</b></summary>
          <div class="hr"></div>

          <div class="row">
            <button id="btnCreateOffer">–°–æ–∑–¥–∞—Ç—å Offer</button>
            <button id="btnApplyRemote" class="secondary" title="–í—Å—Ç–∞–≤—å—Ç–µ Offer/Answer –Ω–∏–∂–µ –∏ –Ω–∞–∂–º–∏—Ç–µ">–ü—Ä–∏–Ω—è—Ç—å –≤—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–µ (Offer/Answer)</button>
            <button id="btnCopyLocal" class="secondary">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –º–æ—ë (Offer/Answer)</button>
          </div>

          <label style="margin-top:10px;">–ú–æ—ë (Offer/Answer) ‚Äî —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ</label>
          <textarea id="localSdp" placeholder="–¢—É—Ç –ø–æ—è–≤–∏—Ç—Å—è Offer –∏–ª–∏ Answer"></textarea>

          <label style="margin-top:10px;">–í—Å—Ç–∞–≤—å—Ç–µ —Å—é–¥–∞ —Ç–æ, —á—Ç–æ –ø—Ä–∏—Å–ª–∞–ª –¥—Ä—É–≥–æ–π —á–µ–ª–æ–≤–µ–∫ (Offer/Answer)</label>
          <textarea id="remoteSdp" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ JSON (Offer/Answer) —Å—é–¥–∞"></textarea>

          <div class="row" style="margin-top:10px; align-items:flex-start;">
            <div style="flex: 1 1 320px;">
              <div class="row" style="justify-content: space-between;">
                <label style="margin:0;">QR –º–æ–µ–≥–æ Offer/Answer</label>
                <button id="btnMakeSdpQr" class="secondary smallbtn">–û–±–Ω–æ–≤–∏—Ç—å QR</button>
              </div>
              <canvas class="qr" id="qrSdp" width="220" height="220" aria-label="QR –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ Offer/Answer"></canvas>
              <div class="help muted" style="margin-top:6px;">
                QR –∫–æ–¥–∏—Ä—É–µ—Ç Offer/Answer. –ï—Å–ª–∏ QR —Å–ª–∏—à–∫–æ–º –ø–ª–æ—Ç–Ω—ã–π ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ copy/paste –∏–ª–∏ —Ä–µ–∂–∏–º –∫–æ–º–Ω–∞—Ç—ã.
              </div>
            </div>
            <div class="help muted" style="flex: 1 1 360px;">
              <b>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —Ä–µ–∂–∏–º–∞ A:</b>
              <ul>
                <li>–¢–æ–ª—å–∫–æ 1-–Ω–∞-1.</li>
                <li>–û–±–∞ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–Ω–ª–∞–π–Ω –≤–æ –≤—Ä–µ–º—è –æ–±–º–µ–Ω–∞ Offer/Answer.</li>
                <li>–í –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Å–µ—Ç—è—Ö –±–µ–∑ TURN –º–æ–∂–µ—Ç –Ω–µ —Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è.</li>
              </ul>
            </div>
          </div>
        </details>

        <details style="margin-top:10px;">
          <summary class="help"><b>–°–µ—Ç—å (STUN / TURN) ‚Äî –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ</b></summary>
          <div class="hr"></div>
          <div class="help muted">
            <b>–ö–æ–≥–¥–∞ –Ω—É–∂–Ω–æ:</b> –µ—Å–ª–∏ —á–∞—Å—Ç–æ –≤–∏–¥–∏—Ç–µ <span class="mono">ICE: failed</span> –∏–ª–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è.
            TURN ‚Äî —ç—Ç–æ —Ä–µ—Ç—Ä–∞–Ω—Å–ª—è—Ç–æ—Ä (—Å–µ—Ä–≤–µ—Ä), –∫–æ—Ç–æ—Ä—ã–π –ø–æ–≤—ã—à–∞–µ—Ç —à–∞–Ω—Å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è.
            <span class="warn">–ò–∑–º–µ–Ω–µ–Ω–∏—è –ø—Ä–∏–º–µ–Ω—è—Ç—Å—è –ø–æ—Å–ª–µ ¬´–°–±—Ä–æ—Å¬ª.</span>
          </div>

          <div class="two" style="margin-top:10px;">
            <div>
              <label>STUN URLs (–ø–æ –æ–¥–Ω–æ–π –Ω–∞ —Å—Ç—Ä–æ–∫—É –∏–ª–∏ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)</label>
              <textarea id="stunUrls" placeholder="stun:stun.l.google.com:19302\nstun:stun1.l.google.com:19302"></textarea>
              <div class="help muted">–û–±—ã—á–Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ 1‚Äì2 STUN.</div>
            </div>
            <div>
              <label>TURN URLs (–ø–æ –æ–¥–Ω–æ–π –Ω–∞ —Å—Ç—Ä–æ–∫—É –∏–ª–∏ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)</label>
              <textarea id="turnUrls" placeholder="turn:turn.example.com:3478?transport=udp\nturns:turn.example.com:5349?transport=tcp"></textarea>
              <div class="help muted">–ï—Å–ª–∏ TURN –Ω–µ –Ω—É–∂–µ–Ω ‚Äî –æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º.</div>
            </div>
          </div>

          <div class="row" style="margin-top:10px;">
            <div style="flex:1 1 240px;">
              <label>TURN username</label>
              <input id="turnUser" placeholder="username" />
            </div>
            <div style="flex:1 1 240px;">
              <label>TURN password</label>
              <input id="turnPass" type="password" placeholder="password" autocomplete="off" />
              <div class="help muted">–ü–∞—Ä–æ–ª—å –ª—É—á—à–µ –Ω–µ —Ö—Ä–∞–Ω–∏—Ç—å. –ú–æ–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∏–∂–µ (–Ω–∞ —Å–≤–æ–π —Ä–∏—Å–∫).</div>
            </div>
          </div>

          <div class="row" style="margin-top:10px;">
            <div style="flex:1 1 260px;">
              <label>ICE transport policy</label>
              <select id="icePolicy">
                <option value="all">all (–æ–±—ã—á–Ω–æ)</option>
                <option value="relay">relay (—Ç–æ–ª—å–∫–æ TURN)</option>
              </select>
            </div>
            <div style="flex: 1 1 260px;">
              <label>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å TURN –ø–∞—Ä–æ–ª—å –ª–æ–∫–∞–ª—å–Ω–æ</label>
              <select id="turnSave">
                <option value="0">–ù–µ—Ç</option>
                <option value="1">–î–∞</option>
              </select>
            </div>
          </div>
        </details>

        <details style="margin-top:10px;">
          <summary class="help">–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞</summary>
          <div class="hr"></div>
          <div class="kv">
            <div>selfId (room)</div><div class="mono" id="dgSelf">‚Äî</div>
            <div>room</div><div class="mono" id="dgRoom">‚Äî</div>
            <div>peers total</div><div class="mono" id="dgPeers">‚Äî</div>
            <div>datachannels open</div><div class="mono" id="dgDcs">‚Äî</div>
            <div>ws</div><div class="mono" id="dgWS">‚Äî</div>
            <div>e2ee</div><div class="mono" id="dgE2EE">‚Äî</div>
          </div>
          <div class="hr"></div>
          <div class="help">
            –ï—Å–ª–∏ –¥–æ–ª–≥–æ –≤–∏—Å–∏—Ç –Ω–∞ <span class="mono">ICE: checking</span> –∏–ª–∏ –ø–æ—è–≤–ª—è–µ—Ç—Å—è <span class="mono">ICE: failed</span> ‚Äî –ø–æ—á—Ç–∏ –≤—Å–µ–≥–¥–∞ NAT/—Ñ–∞–π—Ä–≤–æ–ª.
            –¢–æ–≥–¥–∞ –Ω—É–∂–µ–Ω TURN –∏–ª–∏ –¥—Ä—É–≥–∞—è —Å–µ—Ç—å.
          </div>
        </details>
      </div>

      <div class="card">
        <div class="row" style="justify-content: space-between; align-items:center;">
          <div>
            <b>–£—á–∞—Å—Ç–Ω–∏–∫–∏</b> <span class="muted" id="participantsCount">(0)</span>
          </div>
          <div class="pactions">
            <button id="btnCopyRoomInfo" class="secondary smallbtn" title="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å room + –º–æ–π shortId (–±–µ–∑ –ø–∞—Ä–æ–ª—è)">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
          </div>
        </div>
        <div class="help muted" style="margin-top:6px;">
          –°—Ç–∞—Ç—É—Å—ã –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç <b>–≤–∞—à—É</b> —Å–≤—è–∑—å —Å –∫–∞–∂–¥—ã–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–º (DC/ICE/RTC). –í mesh —É –≤—Å–µ—Ö –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–æ –≤—Å–µ–º–∏, –Ω–æ –∏–Ω–æ–≥–¥–∞ –Ω—É–∂–Ω—ã TURN/–ø–æ–≤—Ç–æ—Ä.
        </div>
        <div class="plist" id="participantsList" style="margin-top:8px;"></div>

        <div class="hr"></div>
        <div class="chat" id="chat"></div>
        <div class="row" style="margin-top:10px;">
          <input id="msg" placeholder="–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..." />
          <button id="btnSend" disabled>–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
        </div>
        <div class="row" style="margin-top:10px;">
          <button id="btnPing" class="secondary" disabled>Ping</button>
          <button id="btnClearChat" class="secondary">–û—á–∏—Å—Ç–∏—Ç—å —á–∞—Ç</button>
        </div>
      </div>
    </div>
  </div>

  <!-- QR generator library (Project Nayuki, MIT) compiled from typescript-javascript/qrcodegen.ts -->
  <script src="./qrcodegen.js"></script>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const ui = {
    pillPeers: $("pillPeers"),
    pillDC: $("pillDC"),
    pillICE: $("pillICE"),
    pillWS: $("pillWS"),
    pillE2EE: $("pillE2EE"),

    btnReset: $("btnReset"),

    name: $("name"),
    e2eePass: $("e2eePass"),
    btnTogglePass: $("btnTogglePass"),

    wsUrl: $("wsUrl"),
    room: $("room"),
    btnRoomNew: $("btnRoomNew"),
    btnWsConnect: $("btnWsConnect"),
    btnWsDisconnect: $("btnWsDisconnect"),

    inviteLink: $("inviteLink"),
    btnCopyInvite: $("btnCopyInvite"),
    btnShareInvite: $("btnShareInvite"),
    btnMakeRoomQr: $("btnMakeRoomQr"),
    qrRoom: $("qrRoom"),

    scanVideo: $("scanVideo"),
    btnScanStart: $("btnScanStart"),
    btnScanStop: $("btnScanStop"),

    btnCreateOffer: $("btnCreateOffer"),
    btnApplyRemote: $("btnApplyRemote"),
    btnCopyLocal: $("btnCopyLocal"),
    localSdp: $("localSdp"),
    remoteSdp: $("remoteSdp"),
    qrSdp: $("qrSdp"),
    btnMakeSdpQr: $("btnMakeSdpQr"),

    stunUrls: $("stunUrls"),
    turnUrls: $("turnUrls"),
    turnUser: $("turnUser"),
    turnPass: $("turnPass"),
    icePolicy: $("icePolicy"),
    turnSave: $("turnSave"),

    dgSelf: $("dgSelf"),
    dgRoom: $("dgRoom"),
    dgPeers: $("dgPeers"),
    dgDcs: $("dgDcs"),
    dgWS: $("dgWS"),
    dgE2EE: $("dgE2EE"),

    chat: $("chat"),
    msg: $("msg"),
    btnSend: $("btnSend"),
    btnPing: $("btnPing"),
    btnClearChat: $("btnClearChat"),

    participantsCount: $("participantsCount"),
    participantsList: $("participantsList"),
    btnCopyRoomInfo: $("btnCopyRoomInfo"),
  };

  // --------------------------
  // Local storage
  // --------------------------
  const LS = {
    name: "p2p_v3_name",
    wsUrl: "p2p_v3_ws",
    room: "p2p_v3_room",
    stunUrls: "p2p_v3_stun",
    turnUrls: "p2p_v3_turn",
    turnUser: "p2p_v3_turn_user",
    turnPass: "p2p_v3_turn_pass",
    turnSave: "p2p_v3_turn_save",
    icePolicy: "p2p_v3_ice_policy",
  };

  function lsGet(k, d="") { try { return localStorage.getItem(k) ?? d; } catch { return d; } }
  function lsSet(k, v) { try { localStorage.setItem(k, v); } catch {} }

  ui.name.value = lsGet(LS.name, "");
  ui.wsUrl.value = lsGet(LS.wsUrl, "");
  ui.room.value = lsGet(LS.room, "");

  ui.stunUrls.value = lsGet(LS.stunUrls, "stun:stun.l.google.com:19302, stun:stun1.l.google.com:19302");
  ui.turnUrls.value = lsGet(LS.turnUrls, "");
  ui.turnUser.value = lsGet(LS.turnUser, "");

  ui.icePolicy.value = lsGet(LS.icePolicy, "all");
  ui.turnSave.value = lsGet(LS.turnSave, "0");
  if (ui.turnSave.value === "1") ui.turnPass.value = lsGet(LS.turnPass, "");

  ui.name.addEventListener("input", () => {
    lsSet(LS.name, ui.name.value || "");
    // update local roster + let others refresh displayed name
    if (selfId) {
      const r = ensureRoster(selfId);
      if (r) { r.name = (ui.name.value || "").trim() || r.name; r.present = true; r.leftAt = null; }
    }
    scheduleHelloBroadcast();
    renderParticipants();
  });
  ui.wsUrl.addEventListener("input", () => { lsSet(LS.wsUrl, ui.wsUrl.value || ""); refreshInviteUI(); });
  ui.room.addEventListener("input", () => { lsSet(LS.room, ui.room.value || ""); refreshInviteUI(); invalidateE2EE(); });

  ui.stunUrls.addEventListener("input", () => lsSet(LS.stunUrls, ui.stunUrls.value || ""));
  ui.turnUrls.addEventListener("input", () => lsSet(LS.turnUrls, ui.turnUrls.value || ""));
  ui.turnUser.addEventListener("input", () => lsSet(LS.turnUser, ui.turnUser.value || ""));
  ui.icePolicy.addEventListener("change", () => lsSet(LS.icePolicy, ui.icePolicy.value || "all"));
  ui.turnSave.addEventListener("change", () => {
    lsSet(LS.turnSave, ui.turnSave.value);
    if (ui.turnSave.value !== "1") {
      lsSet(LS.turnPass, "");
      ui.turnPass.value = "";
    }
  });
  ui.turnPass.addEventListener("input", () => { if (ui.turnSave.value === "1") lsSet(LS.turnPass, ui.turnPass.value || ""); });

  ui.btnTogglePass.addEventListener("click", () => {
    ui.e2eePass.type = (ui.e2eePass.type === "password") ? "text" : "password";
  });

  // --------------------------
  // UI helpers
  // --------------------------
  function escapeHtml(str) {
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function setPill(el, text, kind = "") {
    el.textContent = text;
    el.classList.remove("ok", "bad");
    if (kind) el.classList.add(kind);
  }

  function addSys(text) {
    const el = document.createElement("div");
    el.className = "msg sys";
    el.innerHTML = `<div class="bubble">${escapeHtml(text)}</div>`;
    ui.chat.appendChild(el);
    ui.chat.scrollTop = ui.chat.scrollHeight;
  }

  function addChat(from, text, me=false) {
    const el = document.createElement("div");
    el.className = "msg " + (me ? "me" : "");
    el.innerHTML = `<div class="bubble"><b>${escapeHtml(from)}:</b> ${escapeHtml(text)}</div>`;
    ui.chat.appendChild(el);
    ui.chat.scrollTop = ui.chat.scrollHeight;
  }

  function shortId(id) {
    if (!id) return "?";
    return id.replace(/-/g, "").slice(0, 8);
  }

  function wsStateText(s) {
    if (!ws) return "off";
    if (s === 0) return "connecting";
    if (s === 1) return "open";
    if (s === 2) return "closing";
    if (s === 3) return "closed";
    return "?";
  }

  // --------------------------
  // Base64url + gzip helpers (also used for QR)
  // --------------------------
  function b64urlEncode(bytes) {
    let bin = "";
    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
    return btoa(bin).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }

  function b64urlDecode(str) {
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    while (str.length % 4) str += "=";
    const bin = atob(str);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return bytes;
  }

  const CAN_GZIP = ("CompressionStream" in window) && ("DecompressionStream" in window);

  async function encodeForQr(text) {
    const bytes = new TextEncoder().encode(text);
    if (CAN_GZIP) {
      const cs = new CompressionStream("gzip");
      const w = cs.writable.getWriter();
      w.write(bytes); w.close();
      const buf = await new Response(cs.readable).arrayBuffer();
      return "p2p1:" + b64urlEncode(new Uint8Array(buf));
    }
    return "p2p0:" + b64urlEncode(bytes);
  }

  async function decodeFromQr(payload) {
    const s = String(payload || "").trim();
    if (s.startsWith("p2p1:")) {
      if (!CAN_GZIP) throw new Error("–ù–µ—Ç DecompressionStream (–Ω—É–∂–µ–Ω —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –±—Ä–∞—É–∑–µ—Ä)");
      const bytes = b64urlDecode(s.slice(5));
      const ds = new DecompressionStream("gzip");
      const w = ds.writable.getWriter();
      w.write(bytes); w.close();
      const buf = await new Response(ds.readable).arrayBuffer();
      return new TextDecoder().decode(buf);
    }
    if (s.startsWith("p2p0:")) {
      const bytes = b64urlDecode(s.slice(5));
      return new TextDecoder().decode(bytes);
    }
    return s;
  }

  // --------------------------
  // E2EE (AES-GCM over DataChannel)
  // --------------------------
  let e2eeKey = null;
  let e2eeCtx = { pass: null, salt: null };

  function roomSalt() {
    // Use room id if available; otherwise fall back.
    const r = (ui.room.value || "").trim() || "manual";
    return "p2pchat:" + r;
  }

  function invalidateE2EE() {
    e2eeKey = null;
    e2eeCtx = { pass: null, salt: null };
    updatePills();
    updateDiag();
  }

  async function getE2EEKey() {
    const pass = (ui.e2eePass.value || "");
    if (!pass) return null;

    const salt = roomSalt();
    if (e2eeKey && e2eeCtx.pass === pass && e2eeCtx.salt === salt) return e2eeKey;

    const enc = new TextEncoder();
    const baseKey = await crypto.subtle.importKey(
      "raw",
      enc.encode(pass),
      "PBKDF2",
      false,
      ["deriveKey"]
    );

    // 100k PBKDF2 iterations is a reasonable baseline for browsers.
    e2eeKey = await crypto.subtle.deriveKey(
      { name: "PBKDF2", salt: enc.encode(salt), iterations: 100000, hash: "SHA-256" },
      baseKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );

    e2eeCtx = { pass, salt };
    updatePills();
    updateDiag();
    return e2eeKey;
  }

  async function wrapMaybeEncrypt(payloadObj) {
    const key = await getE2EEKey();
    if (!key) return payloadObj;

    const iv = crypto.getRandomValues(new Uint8Array(12));
    const pt = new TextEncoder().encode(JSON.stringify(payloadObj));
    const ctBuf = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, pt);
    const ct = new Uint8Array(ctBuf);

    return { t: "e2ee", v: 1, iv: b64urlEncode(iv), ct: b64urlEncode(ct) };
  }

  async function unwrapMaybeDecrypt(msgObj) {
    if (!msgObj || msgObj.t !== "e2ee") return msgObj;
    const key = await getE2EEKey();
    if (!key) throw new Error("E2EE –≤—ã–∫–ª—é—á–µ–Ω (–Ω–µ—Ç –ø–∞—Ä–æ–ª—è)");

    const iv = b64urlDecode(msgObj.iv || "");
    const ct = b64urlDecode(msgObj.ct || "");

    const ptBuf = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);
    const pt = new TextDecoder().decode(ptBuf);
    return JSON.parse(pt);
  }

  ui.e2eePass.addEventListener("input", () => invalidateE2EE());

  // --------------------------
  // WebRTC config
  // --------------------------
  function parseUrls(str) {
    return (str || "")
      .split(/[\n,\s]+/)
      .map(s => s.trim())
      .filter(Boolean);
  }

  function buildRtcConfig() {
    const stun = parseUrls(ui.stunUrls.value);
    const turn = parseUrls(ui.turnUrls.value);

    /** @type {RTCIceServer[]} */
    const iceServers = [];

    if (stun.length) iceServers.push({ urls: stun });

    if (turn.length) {
      const server = { urls: turn };
      const user = (ui.turnUser.value || "").trim();
      const pass = ui.turnPass.value || "";
      if (user) server.username = user;
      if (pass) server.credential = pass;
      iceServers.push(server);
    }

    /** @type {RTCConfiguration} */
    const cfg = { iceServers };
    if (ui.icePolicy.value === "relay") cfg.iceTransportPolicy = "relay";

    return cfg;
  }

  // --------------------------
  // Mode B: room + group mesh
  // --------------------------
  let ws = null;
  let selfId = null;
  let roomMax = null;

  /**
   * Roster entry:
   * { present:boolean, leftAt:number|null, name:string|null,
   *   lastSeen:number, meshOpen:Set<string>|null, meshAt:number|null,
   *   conn:string|null, ice:string|null, dc:string|null,
   *   reconnecting:boolean, reconnectWhy:string|null }
   */
  /** @type {Map<string, any>} */
  const roster = new Map();

  /** @type {Map<string, any>} */
  const reconnectTimers = new Map();

  /** @type {Map<string, {pc:RTCPeerConnection, dc:RTCDataChannel|null, pending:RTCIceCandidate[], ice:string, conn:string}>} */
  const peerConns = new Map();

  function ensureRoster(peerId) {
    if (!peerId) return null;
    if (!roster.has(peerId)) {
      roster.set(peerId, {
        present: true,
        leftAt: null,
        name: null,
        lastSeen: Date.now(),
        meshOpen: null,
        meshAt: null,
        conn: null,
        ice: null,
        dc: null,
        reconnecting: false,
        reconnectWhy: null,
      });
    }
    return roster.get(peerId);
  }

  function markSeen(peerId) {
    const r = ensureRoster(peerId);
    if (!r) return;
    r.lastSeen = Date.now();
  }

  function displayPeerName(peerId) {
    if (peerId === selfId) return localDisplayName() + " (–≤—ã)";
    const r = roster.get(peerId);
    const nm = (r && r.name) ? String(r.name) : "";
    return nm || ("peer:" + shortId(peerId));
  }

  function shouldInitiate(peerId) {
    if (!selfId || !peerId) return false;
    // Deterministic initiator rule to avoid offer-offer races on reconnect.
    return String(selfId) < String(peerId);
  }

  function scheduleReconnect(peerId, why) {
    const r = roster.get(peerId);
    if (!r || !r.present) return;
    if (!ws || ws.readyState !== 1) return;
    if (reconnectTimers.has(peerId)) return;
    if (peerConns.has(peerId)) return; // already trying

    r.reconnecting = true;
    r.reconnectWhy = why || "unknown";
    renderParticipants();

    const base = (why === "disconnected") ? 2500 : 800;
    const jitter = Math.floor(Math.random() * 500);
    const t = setTimeout(() => {
      reconnectTimers.delete(peerId);
      const rr = roster.get(peerId);
      if (!rr || !rr.present) return;
      if (!ws || ws.readyState !== 1) return;
      if (peerConns.has(peerId)) return;

      rr.reconnecting = false;
      rr.reconnectWhy = null;

      if (shouldInitiate(peerId)) {
        addSys(`üîÅ Reconnect: —Å–æ–∑–¥–∞—é offer –¥–ª—è ${displayPeerName(peerId)}`);
        ensurePeerConn(peerId, true);
      } else {
        addSys(`üîÅ Reconnect: –∂–¥—É offer –æ—Ç ${displayPeerName(peerId)}`);
        // The other side should initiate.
        renderParticipants();
      }
    }, base + jitter);
    reconnectTimers.set(peerId, t);
  }

  function wsSend(obj) {
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify(obj));
  }

  function closePeer(peerId) {
    const st = peerConns.get(peerId);
    if (!st) return;
    try { st.dc?.close(); } catch {}
    try { st.pc?.close(); } catch {}
    peerConns.delete(peerId);
    // Keep roster/name so user can see who left.
    updatePills();
    updateDiag();
    renderParticipants();
  }

  function closeAllPeers() {
    for (const pid of [...peerConns.keys()]) closePeer(pid);
  }

  function wireDataChannel(peerId, dc) {
    dc.onopen = async () => {
      markSeen(peerId);
      addSys(`‚úÖ DC open —Å ${displayPeerName(peerId)}`);
      updatePills();
      updateDiag();
      renderParticipants();
      // Send hello so peers can display names even before first message.
      try {
        await sendToPeer(peerId, { t: "hello", name: (ui.name.value || "").trim() || "(–±–µ–∑ –∏–º–µ–Ω–∏)", fromId: selfId, at: Date.now() });
      } catch {}

      // Share mesh status (who is connected to whom) after any change.
      scheduleMeshBroadcast();
    };

    dc.onclose = () => {
      addSys(`‚ÑπÔ∏è DC closed: ${displayPeerName(peerId)}`);
      updatePills();
      updateDiag();
      renderParticipants();
      scheduleMeshBroadcast();
    };

    dc.onmessage = async (e) => {
      await handleIncoming(peerId, e.data);
    };
  }

  function ensurePeerConn(peerId, initiator) {
    if (peerConns.has(peerId)) return peerConns.get(peerId);

    // ensure roster
    const r = ensureRoster(peerId);
    if (r) { r.present = true; r.leftAt = null; markSeen(peerId); }

    const pc = new RTCPeerConnection(buildRtcConfig());
    const st = { pc, dc: null, pending: [], ice: "new", conn: "new" };
    peerConns.set(peerId, st);

    pc.onicecandidate = (e) => {
      if (!e.candidate) return;
      wsSend({ t: "signal", to: peerId, data: { t: "candidate", candidate: e.candidate.toJSON() } });
    };

    pc.oniceconnectionstatechange = () => {
      st.ice = pc.iceConnectionState || "?";
      updatePills();
      updateDiag();
      if (st.ice === "failed") {
        addSys(`‚ùå ICE failed —Å ${displayPeerName(peerId)}. –í–æ–∑–º–æ–∂–Ω–æ –Ω—É–∂–µ–Ω TURN.`);
        // Close and try reconnect (deterministically)
        closePeer(peerId);
        scheduleReconnect(peerId, "ice_failed");
      }
      renderParticipants();
    };

    pc.onconnectionstatechange = () => {
      st.conn = pc.connectionState || "?";
      updatePills();
      updateDiag();
      renderParticipants();

      if (st.conn === "failed") {
        closePeer(peerId);
        scheduleReconnect(peerId, "conn_failed");
      }
      if (st.conn === "disconnected") {
        // Give it a moment; if it doesn't recover, reconnect.
        closePeer(peerId);
        scheduleReconnect(peerId, "disconnected");
      }
    };

    pc.ondatachannel = (e) => {
      st.dc = e.channel;
      wireDataChannel(peerId, st.dc);
      updatePills();
      updateDiag();
      renderParticipants();
    };

    if (initiator) {
      st.dc = pc.createDataChannel("chat", { ordered: true });
      wireDataChannel(peerId, st.dc);

      (async () => {
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          wsSend({ t: "signal", to: peerId, data: { t: "offer", desc: { type: pc.localDescription.type, sdp: pc.localDescription.sdp } } });
        } catch (e) {
          addSys(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å offer –¥–ª—è ${shortId(peerId)}: ${e?.message || e}`);
        }
      })();
    }

    updatePills();
    updateDiag();
    renderParticipants();
    return st;
  }

  async function handleSignal(from, data) {
    if (!from || !data) return;

    if (data.t === "offer" && data.desc) {
      const st = ensurePeerConn(from, false);
      await st.pc.setRemoteDescription(new RTCSessionDescription(data.desc));

      const answer = await st.pc.createAnswer();
      await st.pc.setLocalDescription(answer);

      wsSend({ t: "signal", to: from, data: { t: "answer", desc: { type: st.pc.localDescription.type, sdp: st.pc.localDescription.sdp } } });

      // Apply buffered ICE
      for (const c of st.pending) {
        try { await st.pc.addIceCandidate(c); } catch {}
      }
      st.pending = [];
      return;
    }

    if (data.t === "answer" && data.desc) {
      const st = ensurePeerConn(from, false);
      await st.pc.setRemoteDescription(new RTCSessionDescription(data.desc));

      for (const c of st.pending) {
        try { await st.pc.addIceCandidate(c); } catch {}
      }
      st.pending = [];
      return;
    }

    if (data.t === "candidate" && data.candidate) {
      const st = ensurePeerConn(from, false);
      try {
        const c = new RTCIceCandidate(data.candidate);
        if (st.pc.remoteDescription) {
          await st.pc.addIceCandidate(c);
        } else {
          st.pending.push(c);
        }
      } catch {}
      return;
    }
  }

  function connectWs() {
    const base = (ui.wsUrl.value || "").trim();
    const room = (ui.room.value || "").trim();

    if (!base) { addSys("‚ùó –£–∫–∞–∂–∏—Ç–µ WS URL —Å–∏–≥–Ω–∞–ª–∏–Ω–≥–∞."); return; }
    if (!room) { addSys("‚ùó –£–∫–∞–∂–∏—Ç–µ –∫–æ–º–Ω–∞—Ç—É."); return; }

    // close previous ws (but keep existing p2p if you want; reset button closes everything)
    if (ws) { try { ws.close(); } catch {} }

    let url;
    try { url = new URL(base); } catch { addSys("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π WS URL."); return; }
    url.searchParams.set("room", room);

    // Reset room state
    selfId = null;
    roomMax = null;

    setPill(ui.pillWS, "WS: connecting");
    updatePills();
    updateDiag();

    ws = new WebSocket(url.toString());

    ws.onopen = () => {
      setPill(ui.pillWS, "WS: open", "ok");
      ui.btnWsConnect.disabled = true;
      ui.btnWsDisconnect.disabled = false;
      addSys("‚úÖ (WS) –ü–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ –∫–æ–º–Ω–∞—Ç–µ: " + room);
      refreshInviteUI();
      updatePills();
      updateDiag();
    };

    ws.onclose = () => {
      setPill(ui.pillWS, "WS: closed");
      ui.btnWsConnect.disabled = false;
      ui.btnWsDisconnect.disabled = true;
      addSys("‚ÑπÔ∏è (WS) –°–∏–≥–Ω–∞–ª–∏–Ω–≥ –æ—Ç–∫–ª—é—á—ë–Ω.");
      updatePills();
      updateDiag();
    };

    ws.onerror = () => {
      setPill(ui.pillWS, "WS: error", "bad");
      addSys("‚ùå (WS) –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è.");
      updatePills();
      updateDiag();
    };

    ws.onmessage = async (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.t === "welcome") {
        selfId = msg.id || null;
        roomMax = msg.max || null;
        const peers = Array.isArray(msg.peers) ? msg.peers : [];

        // roster self
        if (selfId) {
          const rSelf = ensureRoster(selfId);
          if (rSelf) {
            rSelf.present = true;
            rSelf.leftAt = null;
            rSelf.name = (ui.name.value || "").trim() || null;
            markSeen(selfId);
          }
        }

        // roster existing peers
        for (const p of peers) {
          if (!p?.id) continue;
          const r = ensureRoster(p.id);
          if (r) { r.present = true; r.leftAt = null; markSeen(p.id); }
        }

        addSys(`(WS) –í—ã –≤ –∫–æ–º–Ω–∞—Ç–µ. selfId=${shortId(selfId)}. peers —Å–µ–π—á–∞—Å: ${peers.length}${roomMax ? "/" + roomMax : ""}`);

        // New peer initiates offers to all existing peers.
        for (const p of peers) {
          if (!p?.id) continue;
          ensurePeerConn(p.id, true);
        }

        updatePills();
        updateDiag();
        renderParticipants();
        return;
      }

      if (msg.t === "peer_join" && msg.id) {
        ensureRoster(msg.id);
        const r = roster.get(msg.id);
        if (r) { r.present = true; r.leftAt = null; markSeen(msg.id); }
        addSys(`‚ûï –í –∫–æ–º–Ω–∞—Ç—É –≤–æ—à—ë–ª ${displayPeerName(msg.id)} (–æ–Ω –∏–Ω–∏—Ü–∏–∏—Ä—É–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è).`);
        updatePills();
        updateDiag();
        renderParticipants();
        return;
      }

      if (msg.t === "peer_leave" && msg.id) {
        const r = ensureRoster(msg.id);
        if (r) { r.present = false; r.leftAt = Date.now(); }
        addSys(`‚ûñ –í—ã—à–µ–ª ${displayPeerName(msg.id)}`);
        closePeer(msg.id);
        renderParticipants();
        return;
      }

      if (msg.t === "signal" && msg.from && msg.data) {
        await handleSignal(msg.from, msg.data);
        return;
      }

      if (msg.t === "room_full") {
        addSys(`‚ùå –ö–æ–º–Ω–∞—Ç–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞. max=${msg.max || "?"}`);
        return;
      }
    };

    updateDiag();
  }

  function disconnectWs() {
    if (!ws) return;
    try { ws.close(1000, "bye"); } catch {}
  }

  // --------------------------
  // Mode A: manual 1:1 offer/answer (non-trickle)
  // --------------------------
  let pcManual = null;
  let dcManual = null;

  function ensureManualPC() {
    if (pcManual) return;

    pcManual = new RTCPeerConnection(buildRtcConfig());

    pcManual.oniceconnectionstatechange = () => {
      updatePills();
      updateDiag();
    };

    pcManual.onconnectionstatechange = () => {
      updatePills();
      updateDiag();
    };

    pcManual.ondatachannel = (e) => {
      dcManual = e.channel;
      wireManualDC(dcManual);
      updatePills();
      updateDiag();
    };
  }

  function wireManualDC(dc) {
    dc.onopen = async () => {
      addSys("‚úÖ (manual) DataChannel –æ—Ç–∫—Ä—ã—Ç.");
      updatePills();
      updateDiag();
    };
    dc.onclose = () => {
      addSys("‚ÑπÔ∏è (manual) DataChannel –∑–∞–∫—Ä—ã—Ç.");
      updatePills();
      updateDiag();
    };
    dc.onmessage = async (e) => {
      await handleIncoming("manual", e.data);
    };
  }

  async function waitIceGatheringComplete(pc) {
    if (!pc) return;
    if (pc.iceGatheringState === "complete") return;
    await new Promise((resolve) => {
      const check = () => {
        if (pc.iceGatheringState === "complete") {
          pc.removeEventListener("icegatheringstatechange", check);
          resolve();
        }
      };
      pc.addEventListener("icegatheringstatechange", check);
    });
  }

  function packSDP(desc) {
    return JSON.stringify({ type: desc.type, sdp: desc.sdp }, null, 2);
  }

  function unpackSDP(text) {
    const obj = JSON.parse(text);
    if (!obj || !obj.type || !obj.sdp) throw new Error("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç SDP JSON");
    return new RTCSessionDescription({ type: obj.type, sdp: obj.sdp });
  }

  async function createOfferManual() {
    ensureManualPC();

    if (!dcManual) {
      dcManual = pcManual.createDataChannel("chat", { ordered: true });
      wireManualDC(dcManual);
    }

    addSys("(manual) –°–æ–∑–¥–∞—é Offer‚Ä¶");
    const offer = await pcManual.createOffer();
    await pcManual.setLocalDescription(offer);
    await waitIceGatheringComplete(pcManual);

    ui.localSdp.value = packSDP(pcManual.localDescription);
    addSys("‚úÖ (manual) Offer –≥–æ—Ç–æ–≤. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ/–ø–µ—Ä–µ–¥–∞–π—Ç–µ –¥—Ä—É–≥–æ–π —Å—Ç–æ—Ä–æ–Ω–µ.");
    updatePills();
    updateDiag();
  }

  async function applyRemoteManual() {
    ensureManualPC();

    const remoteText = (ui.remoteSdp.value || "").trim();
    if (!remoteText) { addSys("‚ùó (manual) –í—Å—Ç–∞–≤—å—Ç–µ Offer/Answer –≤ –ø–æ–ª–µ Remote."); return; }

    let remoteDesc;
    try { remoteDesc = unpackSDP(remoteText); }
    catch (e) { addSys("‚ùå (manual) –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ SDP: " + e.message); return; }

    addSys("(manual) –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é Remote SDP (" + remoteDesc.type + ")‚Ä¶");
    await pcManual.setRemoteDescription(remoteDesc);

    if (remoteDesc.type === "offer") {
      addSys("(manual) –°–æ–∑–¥–∞—é Answer‚Ä¶");
      const answer = await pcManual.createAnswer();
      await pcManual.setLocalDescription(answer);
      await waitIceGatheringComplete(pcManual);
      ui.localSdp.value = packSDP(pcManual.localDescription);
      addSys("‚úÖ (manual) Answer –≥–æ—Ç–æ–≤. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä—É.");
    } else {
      addSys("‚úÖ (manual) Answer –ø—Ä–∏–Ω—è—Ç. –ñ–¥—ë–º –æ—Ç–∫—Ä—ã—Ç–∏—è DC‚Ä¶");
    }

    updatePills();
    updateDiag();
  }

  async function copyLocal() {
    const t = (ui.localSdp.value || "").trim();
    if (!t) { addSys("‚ùó –ù–µ—á–µ–≥–æ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å (Offer/Answer –ø—É—Å—Ç–æ–π)." ); return; }
    try {
      await navigator.clipboard.writeText(t);
      addSys("üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞.");
    } catch {
      addSys("‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –≤—Ä—É—á–Ω—É—é.");
    }
  }

  // --------------------------
  // DataChannel messaging (shared)
  // --------------------------
  function localDisplayName() {
    return (ui.name.value || "").trim() || "–í—ã";
  }

  function openChannels() {
    const chans = [];
    for (const [pid, st] of peerConns.entries()) {
      if (st.dc && st.dc.readyState === "open") chans.push({ peerId: pid, dc: st.dc });
    }
    if (dcManual && dcManual.readyState === "open") chans.push({ peerId: "manual", dc: dcManual });
    return chans;
  }

  async function sendToPeer(peerId, payloadObj) {
    // Used for hello, etc.
    const st = peerConns.get(peerId);
    const dc = st?.dc;
    if (!dc || dc.readyState !== "open") return;

    const wrapped = await wrapMaybeEncrypt(payloadObj);
    dc.send(JSON.stringify(wrapped));
  }

  async function broadcast(payloadObj) {
    const chans = openChannels();
    if (!chans.length) throw new Error("–ù–µ—Ç –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π");

    const wrapped = await wrapMaybeEncrypt(payloadObj);
    const wire = JSON.stringify(wrapped);
    for (const c of chans) {
      try { c.dc.send(wire); } catch {}
    }
  }

  // Debounced "presence" broadcasts
  let meshTimer = null;
  let helloTimer = null;

  function scheduleMeshBroadcast() {
    if (meshTimer) return;
    meshTimer = setTimeout(async () => {
      meshTimer = null;
      await broadcastMeshStatus();
    }, 600);
  }

  function scheduleHelloBroadcast() {
    if (helloTimer) return;
    helloTimer = setTimeout(async () => {
      helloTimer = null;
      const name = (ui.name.value || "").trim() || "(–±–µ–∑ –∏–º–µ–Ω–∏)";
      if (selfId) {
        const r = ensureRoster(selfId);
        if (r) { r.name = name; r.present = true; r.leftAt = null; }
      }
      try {
        await broadcast({ t: "hello", name, fromId: selfId, at: Date.now() });
      } catch {}
      renderParticipants();
    }, 450);
  }

  async function broadcastMeshStatus() {
    if (!selfId) return;
    // List room-peers with open DC
    const open = [];
    for (const [pid, st] of peerConns.entries()) {
      if (st.dc && st.dc.readyState === "open") open.push(pid);
    }
    const rSelf = ensureRoster(selfId);
    if (rSelf) {
      rSelf.meshOpen = new Set(open);
      rSelf.meshAt = Date.now();
      rSelf.present = true;
      rSelf.leftAt = null;
      rSelf.name = (ui.name.value || "").trim() || rSelf.name;
    }
    try {
      await broadcast({ t: "mesh", open, at: Date.now(), fromId: selfId });
    } catch {}
    renderParticipants();
  }

  async function handleIncoming(peerId, raw) {
    let msg;
    try { msg = JSON.parse(raw); }
    catch {
      const from = (peerId === "manual") ? "Peer" : displayPeerName(peerId);
      addChat(from, String(raw), false);
      return;
    }

    // ping/pong (unencrypted)
    if (msg && msg.t === "ping") {
      // reply
      const reply = { t: "pong", at: Date.now() };
      if (peerId === "manual") {
        try { dcManual?.send(JSON.stringify(reply)); } catch {}
      } else {
        try { peerConns.get(peerId)?.dc?.send(JSON.stringify(reply)); } catch {}
      }
      addSys(`‚¨ÖÔ∏è ping –æ—Ç ${(peerId === "manual") ? "Peer" : displayPeerName(peerId)}`);
      return;
    }
    if (msg && msg.t === "pong") {
      addSys(`‚¨ÖÔ∏è pong –æ—Ç ${(peerId === "manual") ? "Peer" : displayPeerName(peerId)}`);
      return;
    }

    // decrypt if needed
    if (msg && msg.t === "e2ee") {
      try {
        msg = await unwrapMaybeDecrypt(msg);
      } catch (e) {
        addSys(`üîí –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç ${peerId === "manual" ? "Peer" : ("peer:" + shortId(peerId))} (–ø–∞—Ä–æ–ª—å –Ω–µ–≤–µ—Ä–Ω—ã–π?)`);
        return;
      }
    }

    if (!msg || typeof msg !== "object") return;

    if (msg.t === "hello") {
      const nm = String(msg.name || "").trim();
      if (peerId !== "manual" && nm) {
        const r = ensureRoster(peerId);
        if (r) r.name = nm;
        markSeen(peerId);
      }
      addSys(`üëã ${nm || (peerId === "manual" ? "Peer" : ("peer:" + shortId(peerId)))} –Ω–∞ —Å–≤—è–∑–∏`);
      updatePills();
      updateDiag();
      renderParticipants();
      return;
    }

    if (msg.t === "mesh") {
      if (peerId !== "manual") {
        const r = ensureRoster(peerId);
        if (r) {
          const arr = Array.isArray(msg.open) ? msg.open.map(String) : [];
          r.meshOpen = new Set(arr);
          r.meshAt = Date.now();
          markSeen(peerId);
        }
        updatePills();
        updateDiag();
        renderParticipants();
      }
      return;
    }

    if (msg.t === "chat") {
      const from = String(msg.from || "").trim() || ((peerId === "manual") ? "Peer" : displayPeerName(peerId));
      const text = String(msg.text || "");

      // learn name mapping for room peers
      if (peerId !== "manual" && msg.fromId && from) {
        const r = ensureRoster(peerId);
        if (r) r.name = from;
        markSeen(peerId);
      }

      addChat(from, text, false);
      updatePills();
      updateDiag();
      renderParticipants();
      return;
    }

    // fallback
    addSys(`‚ÑπÔ∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: ${escapeHtml(JSON.stringify(msg)).slice(0, 300)}`);
  }

  // --------------------------
  // QR rendering
  // --------------------------
  function drawQrTextToCanvas(text, canvas) {
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let qr;
    try {
      qr = qrcodegen.QrCode.encodeText(String(text), qrcodegen.QrCode.Ecc.LOW);
    } catch {
      ctx.fillStyle = "#000";
      ctx.font = "12px ui-monospace, monospace";
      ctx.fillText("QR too big", 10, 20);
      return false;
    }

    const border = 2;
    const size = qr.size;
    const scale = Math.floor(Math.min(canvas.width, canvas.height) / (size + border * 2));
    const drawSize = (size + border * 2) * scale;
    const ox = Math.floor((canvas.width - drawSize) / 2);
    const oy = Math.floor((canvas.height - drawSize) / 2);

    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#000";
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        if (qr.getModule(x, y)) {
          ctx.fillRect(ox + (x + border) * scale, oy + (y + border) * scale, scale, scale);
        }
      }
    }

    return true;
  }

  function clearQrCanvases() {
    for (const c of [ui.qrRoom, ui.qrSdp]) {
      const ctx = c.getContext("2d");
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, c.width, c.height);
    }
  }

  async function makeSdpQr() {
    const t = (ui.localSdp.value || "").trim();
    if (!t) { addSys("‚ùó –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ Offer/Answer."); return; }

    let encoded;
    try { encoded = await encodeForQr(t); }
    catch (e) { addSys("‚ùå –ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è QR: " + (e?.message || e)); return; }

    const ok = drawQrTextToCanvas(encoded, ui.qrSdp);
    if (!ok) addSys("‚ùå QR –Ω–µ –≤–ª–µ–∑ (—Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –¥–∞–Ω–Ω—ã—Ö). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–µ–∂–∏–º –∫–æ–º–Ω–∞—Ç—ã –∏–ª–∏ copy/paste.");
    else addSys("‚úÖ QR –¥–ª—è Offer/Answer –æ–±–Ω–æ–≤–ª—ë–Ω.");
  }

  function basePageUrl() {
    const u = new URL(location.href);
    u.search = "";
    u.hash = "";
    return u;
  }

  function makeInviteUrl() {
    const wsUrl = (ui.wsUrl.value || "").trim();
    const room = (ui.room.value || "").trim();
    if (!wsUrl || !room) return "";

    const u = basePageUrl();
    u.searchParams.set("ws", wsUrl);
    u.searchParams.set("room", room);
    u.searchParams.set("autojoin", "1");
    u.searchParams.set("mode", "room");
    return u.toString();
  }

  function refreshInviteUI() {
    const link = makeInviteUrl();
    ui.inviteLink.value = link;
    // If QR already present, refresh it
    if (link) drawQrTextToCanvas(link, ui.qrRoom);
  }

  function makeRoomQr() {
    const link = makeInviteUrl();
    if (!link) { addSys("‚ùó –ó–∞–ø–æ–ª–Ω–∏—Ç–µ WS URL –∏ –∫–æ–º–Ω–∞—Ç—É."); return; }
    const ok = drawQrTextToCanvas(link, ui.qrRoom);
    if (!ok) addSys("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–¥–µ–ª–∞—Ç—å QR –∫–æ–º–Ω–∞—Ç—ã.");
    else addSys("‚úÖ QR –∫–æ–º–Ω–∞—Ç—ã –æ–±–Ω–æ–≤–ª—ë–Ω.");
  }

  async function copyInvite() {
    const link = (ui.inviteLink.value || "").trim();
    if (!link) { addSys("‚ùó –ù–µ—Ç —Å—Å—ã–ª–∫–∏. –°–æ–∑–¥–∞–π—Ç–µ –∫–æ–º–Ω–∞—Ç—É –∏–ª–∏ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–ª—è."); return; }
    try { await navigator.clipboard.writeText(link); addSys("üìã –°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞."); }
    catch { addSys("‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –≤—Ä—É—á–Ω—É—é."); }
  }

  async function shareInvite() {
    const link = (ui.inviteLink.value || "").trim();
    if (!link) { addSys("‚ùó –ù–µ—Ç —Å—Å—ã–ª–∫–∏. –°–æ–∑–¥–∞–π—Ç–µ –∫–æ–º–Ω–∞—Ç—É –∏–ª–∏ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–ª—è."); return; }

    if (navigator.share) {
      try {
        await navigator.share({ title: "P2P Chat invite", text: "–ö–æ–º–Ω–∞—Ç–∞ –¥–ª—è P2P —á–∞—Ç–∞", url: link });
        addSys("‚úÖ –û–∫, –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ.");
        return;
      } catch {
        // fallback to copy
      }
    }
    await copyInvite();
  }

  // --------------------------
  // QR scanning
  // --------------------------
  let scanStream = null;
  let scanStopFlag = false;

  async function onScanned(raw) {
    const s = String(raw || "").trim();

    // URL invite?
    if (/^https?:\/\//i.test(s)) {
      try {
        const u = new URL(s);
        const wsParam = u.searchParams.get("ws");
        const roomParam = u.searchParams.get("room");
        const autojoin = u.searchParams.get("autojoin") === "1";
        if (wsParam && roomParam) {
          ui.wsUrl.value = wsParam;
          ui.room.value = roomParam;
          lsSet(LS.wsUrl, ui.wsUrl.value);
          lsSet(LS.room, ui.room.value);
          refreshInviteUI();
          addSys("‚úÖ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–æ –∏–∑ QR. " + (autojoin ? "–ü–æ–¥–∫–ª—é—á–∞—é—Å—å‚Ä¶" : "–ù–∞–∂–º–∏—Ç–µ '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è'."));
          if (autojoin) connectWs();
          return;
        }
      } catch {}
    }

    // Legacy room QR (older versions)
    if (s.startsWith("p2proom:")) {
      const rest = s.slice("p2proom:".length);
      const parts = rest.split("|");
      if (parts.length >= 2) {
        ui.wsUrl.value = parts[0];
        ui.room.value = parts[1];
        lsSet(LS.wsUrl, ui.wsUrl.value);
        lsSet(LS.room, ui.room.value);
        refreshInviteUI();
        addSys("‚úÖ QR –∫–æ–º–Ω–∞—Ç—ã –ø—Ä–∏–º–µ–Ω—ë–Ω. –ü–æ–¥–∫–ª—é—á–∞—é—Å—å‚Ä¶");
        connectWs();
        return;
      }
    }

    // SDP QR
    let decoded;
    try { decoded = await decodeFromQr(s); }
    catch (e) { addSys("‚ùå –ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å QR: " + (e?.message || e)); return; }

    ui.remoteSdp.value = decoded;
    addSys("‚úÖ QR –≤—Å—Ç–∞–≤–ª–µ–Ω –≤ Remote. –ü—Ä–∏–º–µ–Ω—è—é‚Ä¶");
    try { await applyRemoteManual(); }
    catch (e) { addSys("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è Remote: " + (e?.message || e)); }
  }

  async function scanLoop(detector) {
    while (!scanStopFlag) {
      try {
        const barcodes = await detector.detect(ui.scanVideo);
        if (barcodes && barcodes.length) {
          const raw = barcodes[0].rawValue;
          addSys("üì∑ QR –Ω–∞–π–¥–µ–Ω. –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é‚Ä¶");
          await onScanned(raw);
          await stopScan();
          return;
        }
      } catch {}
      await new Promise(r => setTimeout(r, 120));
    }
  }

  async function startScan() {
    if (!("BarcodeDetector" in window)) {
      addSys("‚ùå BarcodeDetector –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ —ç—Ç–æ–º –±—Ä–∞—É–∑–µ—Ä–µ. –ù–∞ iPhone –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–∏—Å—Ç–µ–º–Ω—É—é –∫–∞–º–µ—Ä—É –¥–ª—è QR-—Å—Å—ã–ª–∫–∏.");
      return;
    }
    if (!navigator.mediaDevices?.getUserMedia) {
      addSys("‚ùå getUserMedia –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ù—É–∂–µ–Ω HTTPS –∏–ª–∏ localhost.");
      return;
    }

    scanStopFlag = false;

    try {
      scanStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
      ui.scanVideo.srcObject = scanStream;
      await ui.scanVideo.play();
    } catch (e) {
      addSys("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –∫–∞–º–µ—Ä—É: " + (e?.message || e));
      return;
    }

    ui.btnScanStart.disabled = true;
    ui.btnScanStop.disabled = false;

    const detector = new BarcodeDetector({ formats: ["qr_code"] });
    addSys("üì∑ –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—É—â–µ–Ω–æ.");
    scanLoop(detector);
  }

  async function stopScan() {
    scanStopFlag = true;
    ui.btnScanStart.disabled = false;
    ui.btnScanStop.disabled = true;

    try {
      ui.scanVideo.pause();
      ui.scanVideo.srcObject = null;
    } catch {}

    if (scanStream) {
      for (const tr of scanStream.getTracks()) {
        try { tr.stop(); } catch {}
      }
    }
    scanStream = null;
  }

  // --------------------------
  // Pills + diag
  // --------------------------
  function updatePills() {
    const openDcs = openChannels().length;

    // Room participants count (WS roster) if available; fallback to connection count.
    let roomCount = 0;
    if (ws && ws.readyState === 1) {
      for (const r of roster.values()) if (r.present) roomCount++;
      // If WS is open but roster not populated yet, show 1 (self).
      if (roomCount === 0) roomCount = selfId ? 1 : 0;
    } else {
      roomCount = peerConns.size + (dcManual && dcManual.readyState === "open" ? 1 : 0);
    }

    const mx = roomMax ? ("/" + roomMax) : "";
    setPill(ui.pillPeers, `Peers: ${roomCount}${mx}`, roomCount > 1 ? "ok" : "");
    setPill(ui.pillDC, `DC: ${openDcs}`, openDcs > 0 ? "ok" : "");

    // ICE summary
    let ice = "idle";
    let anyFailed = false;
    let anyChecking = false;
    for (const st of peerConns.values()) {
      const s = st.ice || "";
      if (s === "failed") anyFailed = true;
      if (s === "checking") anyChecking = true;
      if (s === "connected" || s === "completed") ice = "ok";
    }
    if (anyFailed) {
      setPill(ui.pillICE, "ICE: failed", "bad");
    } else if (anyChecking) {
      setPill(ui.pillICE, "ICE: checking");
    } else {
      setPill(ui.pillICE, "ICE: " + ice, ice === "ok" ? "ok" : "");
    }

    // WS pill
    if (!ws) setPill(ui.pillWS, "WS: off");
    else {
      const s = wsStateText(ws.readyState);
      setPill(ui.pillWS, "WS: " + s, s === "open" ? "ok" : (s === "error" ? "bad" : ""));
    }

    // E2EE pill
    const e = (ui.e2eePass.value || "").length > 0;
    setPill(ui.pillE2EE, e ? "E2EE: on" : "E2EE: off", e ? "ok" : "");

    // send button enabled if any channel open
    ui.btnSend.disabled = openDcs === 0;
    ui.btnPing.disabled = openDcs === 0;
  }

  function updateDiag() {
    ui.dgSelf.textContent = selfId ? shortId(selfId) : "‚Äî";
    ui.dgRoom.textContent = (ui.room.value || "").trim() || "‚Äî";
    ui.dgPeers.textContent = String(peerConns.size) + (ws && ws.readyState === 1 ? (" (roster:" + roster.size + ")") : "");
    ui.dgDcs.textContent = String(openChannels().length);
    ui.dgWS.textContent = ws ? wsStateText(ws.readyState) : "off";

    const pass = (ui.e2eePass.value || "");
    ui.dgE2EE.textContent = pass ? ("on (salt=" + roomSalt() + ")") : "off";
  }

  // --------------------------
  // Participants list (roster)
  // --------------------------
  function fmtAgo(ts) {
    if (!ts) return "‚Äî";
    const sec = Math.max(0, Math.floor((Date.now() - ts) / 1000));
    if (sec < 60) return sec + "s";
    const min = Math.floor(sec / 60);
    if (min < 60) return min + "m";
    const hr = Math.floor(min / 60);
    return hr + "h";
  }

  function pruneRoster() {
    const TTL = 10 * 60 * 1000; // keep "left" peers for 10 minutes
    const now = Date.now();
    for (const [id, r] of roster.entries()) {
      if (id === selfId) continue;
      if (r.present) continue;
      if (peerConns.has(id)) continue;
      if (r.leftAt && (now - r.leftAt > TTL)) roster.delete(id);
    }
  }

  function renderParticipants() {
    if (!ui.participantsList) return;
    pruneRoster();

    // room participants
    const presentIds = [];
    for (const [id, r] of roster.entries()) if (r.present) presentIds.push(id);
    const roomCount = (ws && ws.readyState === 1) ? (presentIds.length || (selfId ? 1 : 0)) : presentIds.length;
    const mx = roomMax ? ("/" + roomMax) : "";
    ui.participantsCount.textContent = `(${roomCount}${mx})`;

    // self computed mesh
    const selfOpen = [];
    for (const [pid, st] of peerConns.entries()) {
      if (st.dc && st.dc.readyState === "open") selfOpen.push(pid);
    }
    const target = Math.max(0, roomCount - 1);
    const selfMeshCount = selfOpen.length;

    const rows = [];

    // self row
    rows.push({
      id: selfId || "local",
      isSelf: true,
      name: localDisplayName() + " (–≤—ã)",
      dot: (ws && ws.readyState === 1) ? (selfMeshCount ? "ok" : "warn") : "",
      tags: [ (ws && ws.readyState === 1) ? { t:"ws", k:"ok" } : { t:"ws off", k:"" } ],
      meta: `id:${selfId ? shortId(selfId) : "‚Äî"} ¬∑ dc:${selfMeshCount} ¬∑ mesh:${selfMeshCount}/${target}`,
      title: selfOpen.length ? ("connected to: " + selfOpen.map(displayPeerName).join(", ")) : "",
    });

    // other peers
    const peerIds = [...roster.keys()].filter(id => id !== selfId);
    peerIds.sort((a, b) => {
      const ra = roster.get(a), rb = roster.get(b);
      const pa = ra?.present ? 1 : 0;
      const pb = rb?.present ? 1 : 0;
      if (pa !== pb) return pb - pa;
      const na = (ra?.name || "").toLowerCase();
      const nb = (rb?.name || "").toLowerCase();
      if (na && nb && na !== nb) return na < nb ? -1 : 1;
      return String(a) < String(b) ? -1 : 1;
    });

    for (const pid of peerIds) {
      const r = roster.get(pid);
      const st = peerConns.get(pid);
      const dcState = st?.dc ? st.dc.readyState : "none";
      const iceState = st?.ice || "‚Äî";
      const connState = st?.conn || "‚Äî";

      let dot = "";
      if (r?.present) {
        if (dcState === "open") dot = "ok";
        else if (iceState === "failed" || connState === "failed") dot = "bad";
        else if (r?.reconnecting || iceState === "checking" || connState === "connecting") dot = "warn";
        else dot = "warn";
      }

      const meshCount = r?.meshOpen ? r.meshOpen.size : null;
      const meshText = (meshCount === null) ? `mesh:‚Äî/${target}` : `mesh:${meshCount}/${target}`;

      const tags = [];
      if (r?.present) tags.push({ t:"ws", k:"ok" });
      else tags.push({ t:"left", k:"" });
      if (dcState === "open") tags.push({ t:"dc", k:"ok" });
      if (iceState === "failed" || connState === "failed") tags.push({ t:"fail", k:"bad" });
      if (r?.reconnecting) tags.push({ t:"reconnect", k:"" });

      const leftInfo = (!r?.present && r?.leftAt) ? (` ¬∑ left:${fmtAgo(r.leftAt)} ago`) : "";
      const seenInfo = r?.lastSeen ? (` ¬∑ seen:${fmtAgo(r.lastSeen)} ago`) : "";

      const title = (r?.meshOpen && r.meshOpen.size)
        ? ("connected to: " + [...r.meshOpen].map(displayPeerName).join(", "))
        : "";

      rows.push({
        id: pid,
        isSelf: false,
        name: displayPeerName(pid),
        dot,
        tags,
        meta: `id:${shortId(pid)} ¬∑ dc:${dcState} ¬∑ ice:${iceState} ¬∑ rtc:${connState} ¬∑ ${meshText}${seenInfo}${leftInfo}`,
        title,
      });
    }

    ui.participantsList.innerHTML = rows.map((row) => {
      const tagsHtml = (row.tags || []).map(t => `<span class="tag ${t.k || ""}">${escapeHtml(t.t)}</span>`).join(" ");
      return `
        <div class="prow" ${row.title ? `title="${escapeHtml(row.title)}"` : ""}>
          <div class="dot ${row.dot || ""}"></div>
          <div style="flex:1; min-width: 0;">
            <div class="pname">${escapeHtml(row.name)}</div>
            <div class="pmeta mono">${escapeHtml(row.meta)}</div>
          </div>
          <div style="display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end;">${tagsHtml}</div>
        </div>
      `;
    }).join("");
  }

  // --------------------------
  // Reset
  // --------------------------
  function resetAll() {
    stopScan();

    // Close room peers
    closeAllPeers();

    // Cancel reconnect timers
    for (const t of reconnectTimers.values()) {
      try { clearTimeout(t); } catch {}
    }
    reconnectTimers.clear();

    // Clear roster
    roster.clear();

    // Close manual pc
    try { dcManual?.close(); } catch {}
    try { pcManual?.close(); } catch {}
    dcManual = null;
    pcManual = null;

    // Close WS
    if (ws) { try { ws.close(); } catch {} }
    ws = null;
    selfId = null;
    roomMax = null;

    ui.localSdp.value = "";
    ui.remoteSdp.value = "";

    clearQrCanvases();

    addSys("–°–±—Ä–æ—à–µ–Ω–æ.");
    updatePills();
    updateDiag();
    renderParticipants();
  }

  // --------------------------
  // Buttons
  // --------------------------
  function randRoom(len = 6) {
    const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    let s = "";
    crypto.getRandomValues(new Uint8Array(len)).forEach((b) => s += alphabet[b % alphabet.length]);
    return s;
  }

  ui.btnReset.onclick = () => resetAll();

  ui.btnRoomNew.onclick = () => {
    ui.room.value = randRoom(6);
    lsSet(LS.room, ui.room.value);
    refreshInviteUI();
    invalidateE2EE();
    addSys("‚úÖ –ö–æ–º–Ω–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞: " + ui.room.value);
  };

  ui.btnWsConnect.onclick = () => connectWs();
  ui.btnWsDisconnect.onclick = () => disconnectWs();

  ui.btnMakeRoomQr.onclick = () => makeRoomQr();
  ui.btnCopyInvite.onclick = () => copyInvite();
  ui.btnShareInvite.onclick = () => shareInvite();

  ui.btnCopyRoomInfo.onclick = async () => {
    const room = (ui.room.value || "").trim() || "(no room)";
    const wsUrl = (ui.wsUrl.value || "").trim() || "(no ws)";
    const me = selfId ? shortId(selfId) : "‚Äî";
    const link = (ui.inviteLink.value || "").trim();
    const txt = `room=${room}\nws=${wsUrl}\nme=${me}` + (link ? (`\nlink=${link}`) : "");
    try {
      await navigator.clipboard.writeText(txt);
      addSys("üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ: room/ws/me (–±–µ–∑ –ø–∞—Ä–æ–ª—è)");
    } catch {
      addSys("‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –≤—Ä—É—á–Ω—É—é: " + txt);
    }
  };

  ui.btnScanStart.onclick = () => startScan();
  ui.btnScanStop.onclick = () => stopScan();

  ui.btnCreateOffer.onclick = () => createOfferManual();
  ui.btnApplyRemote.onclick = () => applyRemoteManual();
  ui.btnCopyLocal.onclick = () => copyLocal();
  ui.btnMakeSdpQr.onclick = () => makeSdpQr();

  ui.btnSend.onclick = async () => {
    const text = (ui.msg.value || "").trim();
    if (!text) return;

    const payload = {
      t: "chat",
      from: localDisplayName(),
      fromId: selfId,
      text,
      at: Date.now(),
    };

    try {
      await broadcast(payload);
      addChat(localDisplayName(), text, true);
      ui.msg.value = "";
      updatePills();
      updateDiag();
    } catch (e) {
      addSys("‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å: " + (e?.message || e));
    }
  };

  ui.msg.addEventListener("keydown", (e) => {
    if (e.key === "Enter") ui.btnSend.click();
  });

  ui.btnPing.onclick = async () => {
    const chans = openChannels();
    if (!chans.length) return;
    const wire = JSON.stringify({ t: "ping", at: Date.now() });
    for (const c of chans) {
      try { c.dc.send(wire); } catch {}
    }
    addSys("‚û°Ô∏è ping");
  };

  ui.btnClearChat.onclick = () => {
    ui.chat.innerHTML = "";
    addSys("–ß–∞—Ç –æ—á–∏—â–µ–Ω.");
  };

  // --------------------------
  // Init: parse invite from URL
  // --------------------------
  function applyInviteFromUrl() {
    const u = new URL(location.href);
    const wsParam = u.searchParams.get("ws");
    const roomParam = u.searchParams.get("room");
    const autojoin = u.searchParams.get("autojoin") === "1";

    if (wsParam && roomParam) {
      ui.wsUrl.value = wsParam;
      ui.room.value = roomParam;
      lsSet(LS.wsUrl, ui.wsUrl.value);
      lsSet(LS.room, ui.room.value);
      refreshInviteUI();
      invalidateE2EE();
      addSys("‚úÖ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–æ –∏–∑ —Å—Å—ã–ª–∫–∏." + (autojoin ? " –ü–æ–¥–∫–ª—é—á–∞—é—Å—å‚Ä¶" : ""));
      if (autojoin) connectWs();
    }
  }

  // PWA
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("./sw.js").catch(() => {});
  }

  clearQrCanvases();
  refreshInviteUI();
  applyInviteFromUrl();

  addSys("–ì–æ—Ç–æ–≤–æ. –î–ª—è –≥—Ä—É–ø–ø–æ–≤–æ–≥–æ —á–∞—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–µ–∂–∏–º –∫–æ–º–Ω–∞—Ç—ã. –î–ª—è E2EE –∑–∞–¥–∞–π—Ç–µ –ø–∞—Ä–æ–ª—å.");
  updatePills();
  updateDiag();
  renderParticipants();
})();
</script>
</body>
</html>
